local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/matas3535/gamesneeze/main/Library.lua"))()

local Window = Library:New({
    Name = "Reflect.cc - Apocalypse Rising 2"
})

local aimTab = Window:Page({
    Name = "Combat"
})

local silentAimSection = aimTab:Section({
    Name = "Silent Aim",
    Fill = true,
    Side = "Left"
})

local otherSection = aimTab:Section({
    Name = "Other",
    Fill = true,
    Side = "Right"
})

local playerTab = Window:Page({
    Name = "Players"
})

local ESPSection = playerTab:Section({
    Name = "ESP Settings",
    Fill = true,
    Side = "Left"
})

local playerSection = playerTab:Section({
    Name = "Player Highlights",
    Fill = false,
    Side = "Right"
})

local OOVArrows = playerTab:Section({
    Name = "Player Arrows",
    Fill = true,
    Side = "Right"
})


local apoc2Tab = Window:Page({
    Name = "Apoc2"
})

local esponeSection = apoc2Tab:Section({
    Name = "Zombie Esp",
    Fill = false,
    Side = "Left"
})

local vehicleespSection = apoc2Tab:Section({
    Name = "Vehicle Esp",
    Fill = true,
    Side = "Left"
})

local esptwoSection = apoc2Tab:Section({
    Name = "Corpse Esp",
    Fill = false,
    Side = "Right"
})

local eventespSection = apoc2Tab:Section({
    Name = "Event Esp",
    Fill = true,
    Side = "Right"
})


local visualsTab = Window:Page({
    Name = "Other Visuals"
})

local worldSection = visualsTab:Section({
    Name = "World",
    Fill = true,
    Side = "Left"
})

local miscTab = Window:Page({
    Name = "Misc"
})

local meleeAuraToggle = miscTab:Section({
    Name = "Melee Aura",
    Fill = true,
    Side = "Left"
})

local antizombie = miscTab:Section({
    Name = "Anti Zombie",
    Fill = true,
    Side = "Right"
})


local PlayerPage = Window:Page({
    Name = "LocalPlayer"
})



local runService = game:GetService("RunService")
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer
local camera = workspace.CurrentCamera

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local players = cloneref(game:GetService("Players"))
local client = players.LocalPlayer
local camera = workspace.CurrentCamera
getgenv().global = getgenv()

function global.declare(self, index, value, check)
    if self[index] == nil then
        self[index] = value
    elseif check then
        local methods = { "remove", "Disconnect" }

        for _, method in ipairs(methods) do
            pcall(function()
                value[method](value)
            end)
        end
    end

    return self[index]
end

declare(global, "services", {})

function global.get(service)
    return services[service]
end

declare(declare(services, "loop", {}), "cache", {})

get("loop").new = function(self, index, func, disabled)
    if disabled == nil and (func == nil or typeof(func) == "boolean") then
        disabled = func func = index
    end

    self.cache[index] = {
        ["enabled"] = (not disabled),
        ["func"] = func,
        ["toggle"] = function(self, boolean)
            if boolean == nil then
                self.enabled = not self.enabled
            else
                self.enabled = boolean
            end
        end,
        ["remove"] = function()
            self.cache[index] = nil
        end
    }

    return self.cache[index]
end

declare(get("loop"), "connection", cloneref(game:GetService("RunService")).RenderStepped:Connect(function(delta)
    for _, loop in pairs(get("loop").cache) do
        if loop.enabled then
            local success, result = pcall(function()
                loop.func(delta)
            end)

            if not success then
                warn(result)
            end
        end
    end
end), true)

declare(services, "new", {})

get("new").drawing = function(class, properties)
    local drawing = Drawing.new(class)
    for property, value in pairs(properties) do
        pcall(function()
            drawing[property] = value
        end)
    end
    return drawing
end

declare(declare(services, "player", {}), "cache", {})

get("player").find = function(self, player)
    for character, data in pairs(self.cache) do
        if data.player == player then
            return character
        end
    end
end

get("player").check = function(self, player)
    local success, check = pcall(function()
        local character = player:IsA("Player") and player.Character or player
        local children = { character.Humanoid, character.HumanoidRootPart }

        return children and character.Parent ~= nil
    end)

    return success and check
end

get("player").new = function(self, player)
    local function cache(character)
        print("caching", character)
        self.cache[character] = {
            ["player"] = player,
            ["drawings"] = {
                ["box"] = get("new").drawing("Square", { Visible = false }),
                ["boxFilled"] = get("new").drawing("Square", { Visible = false, Filled = true }),
                ["boxOutline"] = get("new").drawing("Square", { Visible = false }),
                ["name"] = get("new").drawing("Text", { Visible = false, Center = true}),
                ["health"] = get("new").drawing("Line", { Visible = false }),
                ["healthOutline"] = get("new").drawing("Line", { Visible = false }),
                ["healthText"] = get("new").drawing("Text", { Visible = false, Center = false}),
                ["distance"] = get("new").drawing("Text", { Visible = false, Center = true}),
                ["weapon"] = get("new").drawing("Text", { Visible = false, Center = true}),
                ["viewDirection"] = get("new").drawing("Line", { Visible = false }),  -- Added for View Direction
            }
        }
    end

    local function check(character)
        if self:check(character) then
            cache(character)
        else
            local listener; listener = character.ChildAdded:Connect(function()
                if self:check(character) then
                    cache(character) listener:Disconnect()
                end
            end)
        end
    end

    if player.Character then check(player.Character) end
    player.CharacterAdded:Connect(check)
end

get("player").remove = function(self, player)
    print("removing", player)
    if player:IsA("Player") then
        local character = self:find(player)
        if character then
            self:remove(character)
        end
    else
        local drawings = self.cache[player].drawings self.cache[player] = nil

        for _, drawing in pairs(drawings) do
            drawing:Remove()
        end
    end
end

get("player").update = function(self, character, data)
    if not self:check(character) then
        self:remove(character)
    end

    local playerhealth = data.player:FindFirstChild("Stats"):FindFirstChild("Health").Value
    local player = data.player
    local root = character.HumanoidRootPart
    local humanoid = character.Humanoid
    local drawings = data.drawings

    if self:check(client) then
        data.distance = (client.Character.HumanoidRootPart.CFrame.Position - root.CFrame.Position).Magnitude
    end

    local weapon = character:FindFirstChildWhichIsA("Tool") or "none"

    task.spawn(function()
        local position, visible = camera:WorldToViewportPoint(root.CFrame.Position)

        local visuals = features.visuals

local function check()
    local team
    if visuals.teamCheck then
        team = player.Team ~= client.Team
    else
        team = true
    end
    return visuals.enabled and visuals.boundingBox and data.distance and data.distance <= visuals.renderDistance and team
end

local function color(color)
    if visuals.teamColor then
        color = player.TeamColor.Color
    end
    return color
end

if visible and check() then
    local scale = 1 / (position.Z * math.tan(math.rad(camera.FieldOfView * 0.5)) * 2) * 1000
    local width, height = math.floor(4.5 * scale), math.floor(6 * scale)
    local x, y = math.floor(position.X), math.floor(position.Y)
    local xPosition, yPostion = math.floor(x - width * 0.5), math.floor((y - height * 0.5) + (0.5 * scale))

    drawings.box.Size = Vector2.new(width, height)
    drawings.box.Position = Vector2.new(xPosition, yPostion)
    drawings.boxFilled.Size = drawings.box.Size
    drawings.boxFilled.Position = drawings.box.Position
    drawings.boxOutline.Size = drawings.box.Size
    drawings.boxOutline.Position = drawings.box.Position

    drawings.box.Color = color(visuals.boxes.color)
    drawings.box.Thickness = 1
    drawings.boxFilled.Color = color(visuals.boxes.filled.color)
    drawings.boxFilled.Transparency = visuals.boxes.filled.transparency
    drawings.boxOutline.Color = visuals.boxes.outline.color
    drawings.boxOutline.Thickness = 3

    drawings.boxOutline.ZIndex = drawings.box.ZIndex - 1
    drawings.boxFilled.ZIndex = drawings.boxOutline.ZIndex - 1

    drawings.name.Text = `[ {player.Name} ]`
    drawings.name.Size = math.max(math.min(math.abs(12.5 * scale), 12.5), 10)
    drawings.name.Position = Vector2.new(x, (yPostion - drawings.name.TextBounds.Y) - 2)
    drawings.name.Color = color(visuals.names.color)
    drawings.name.Outline = visuals.names.outline.enabled
    drawings.name.OutlineColor = visuals.names.outline.color

    drawings.name.ZIndex = drawings.box.ZIndex + 1

    local healthPercent = 100 / (humanoid.MaxHealth / playerhealth)

    drawings.healthOutline.From = Vector2.new(xPosition - 5, yPostion)
    drawings.healthOutline.To = Vector2.new(xPosition - 5, yPostion + height)
    drawings.health.From = Vector2.new(xPosition - 5, (yPostion + height) - 1)
    drawings.health.To = Vector2.new(xPosition - 5, ((drawings.health.From.Y - ((height / 100) * healthPercent))) + 2)
    drawings.healthText.Text = `[ {math.floor(humanoid.Health)} ]`
    drawings.healthText.Size = math.max(math.min(math.abs(11 * scale), 11), 10)
    drawings.healthText.Position = Vector2.new(drawings.health.To.X - (drawings.healthText.TextBounds.X + 3), (drawings.health.To.Y - (2 / scale)))

    drawings.health.Color = visuals.health.colorLow:Lerp(visuals.health.color, healthPercent * 0.01)
    drawings.healthOutline.Color = visuals.health.outline.color
    drawings.healthOutline.Thickness = 3
    drawings.healthText.Color = drawings.health.Color
    drawings.healthText.Outline = visuals.health.text.outline.enabled
    drawings.healthText.OutlineColor = visuals.health.outline.color

    drawings.healthOutline.ZIndex = drawings.health.ZIndex - 1

    drawings.distance.Text = `[ {math.floor(data.distance)} ]`
    drawings.distance.Size = math.max(math.min(math.abs(11 * scale), 11), 10)
    drawings.distance.Position = Vector2.new(x, (yPostion + height) + (drawings.distance.TextBounds.Y * 0.25))
    drawings.distance.Color = color(visuals.distance.color)
    drawings.distance.Outline = visuals.distance.outline.enabled
    drawings.distance.OutlineColor = visuals.distance.outline.color

    drawings.weapon.Text = `[ {weapon} ]`
    drawings.weapon.Size = math.max(math.min(math.abs(11 * scale), 11), 10)
    drawings.weapon.Position = visuals.distance.enabled and Vector2.new(drawings.distance.Position.x, drawings.distance.Position.Y + (drawings.weapon.TextBounds.Y * 0.75)) or drawings.distance.Position
    drawings.weapon.Color = color(visuals.weapon.color)
    drawings.weapon.Outline = visuals.weapon.outline.enabled
    drawings.weapon.OutlineColor = visuals.weapon.outline.color

    -- View Direction Line
    if features.visuals.viewDirection.enabled then
        local endPosition = root.CFrame.LookVector * features.visuals.viewDirection.length
        local endScreenPosition, endVisible = camera:WorldToViewportPoint(root.Position + endPosition)
        if endVisible then
            drawings.viewDirection.From = Vector2.new(position.X, position.Y)
            drawings.viewDirection.To = Vector2.new(endScreenPosition.X, endScreenPosition.Y)
            drawings.viewDirection.Color = features.visuals.viewDirection.color
            drawings.viewDirection.Thickness = 2
            drawings.viewDirection.Transparency = 1
        else
            drawings.viewDirection.Visible = false
        end
    end
end

drawings.box.Visible = (check() and visible and visuals.boxes.enabled)
drawings.boxFilled.Visible = (check() and drawings.box.Visible and visuals.boxes.filled.enabled)
drawings.boxOutline.Visible = (check() and drawings.box.Visible and visuals.boxes.outline.enabled)
drawings.name.Visible = (check() and visible and visuals.names.enabled)
drawings.health.Visible = (check() and visible and visuals.health.enabled)
drawings.healthOutline.Visible = (check() and drawings.health.Visible and visuals.health.outline.enabled)
drawings.healthText.Visible = (check() and drawings.health.Visible and visuals.health.text.enabled)
drawings.distance.Visible = (check() and visible and visuals.distance.enabled)
drawings.weapon.Visible = (check() and visible and visuals.weapon.enabled)
drawings.viewDirection.Visible = (check() and visible and features.visuals.viewDirection.enabled)  -- View Direction
    end)
end

declare(get("player"), "loop", get("loop"):new(function ()
    for character, data in pairs(get("player").cache) do
        get("player"):update(character, data)
    end
end), true)

declare(global, "features", {})

features.toggle = function(self, feature, boolean)
    if self[feature] then
        if boolean == nil then
            self[feature].enabled = not self[feature].enabled
        else
            self[feature].enabled = boolean
        end

        if self[feature].toggle then
            task.spawn(function()
                self[feature]:toggle()
            end)
        end
    end
end

declare(features, "visuals", {
    ["enabled"] = true,
    ["teamCheck"] = false,
    ["teamColor"] = true,
    ["renderDistance"] = 2000,

    ["boxes"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(255, 255, 255),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0),
        },
        ["filled"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(255, 255, 255),
            ["transparency"] = 0.25
        },
    },
    ["names"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(255, 255, 255),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0),
        },
    },
    ["health"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(0, 255, 0),
        ["colorLow"] = Color3.fromRGB(255, 0, 0),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0)
        },
        ["text"] = {
            ["enabled"] = true,
            ["outline"] = {
                ["enabled"] = true,
            },
        }
    },
    ["distance"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(255, 255, 255),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0),
        },
    },
    ["weapon"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(255, 255, 255),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0),
        },
    },
    ["viewDirection"] = {
        ["enabled"] = false,
        ["color"] = Color3.fromRGB(255, 0, 0),
        ["length"] = 5,
    }
})

for _, player in pairs(players:GetPlayers()) do
    if player ~= client and not get("player"):find(player) then
        get("player"):new(player)
    end
end

declare(get("player"), "added", players.PlayerAdded:Connect(function(player)
    get("player"):new(player)
end), true)

declare(get("player"), "removing", players.PlayerRemoving:Connect(function(player)
    get("player"):remove(player)
end), true)





local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local meleeAuraEnabled = false
local auraDistance = 6
local auraTransparency = 0.5
local auraColor = Color3.new(1, 1, 1)
local showAuraPart = false
local shadowsEnabled = true
local enforceCrosshairSizeEnabled = false
local isKeyPressed = false
local brightness = 0
local saturation = 0
local contrast = 0
local worldColor = Color3.fromRGB(255, 255, 255)
local isScriptActive = false
local useYOffset = true
local yOffsetPerStud = 0
local Players = game:FindService("Players")
local CoreGui = game:FindService("CoreGui")
local localPlayer = Players.LocalPlayer
local connections = {}
local noclipEnabled = false
local highlightEnabled = false
local wallCheckEnabled = fals
local aimKey = Enum.KeyCode.Space
local aimMode = "Nearest"
local fovRadius = 100
local fovTransparency = 1
local useFov = false
local visibleFov = false
local fovColor = Color3.new(1, 1, 1)
local fovCircle
local tracerEnabled = false
local tracerStart = "Center"
local tracerColor = Color3.new(1, 0, 0)
local tracer
local aimBones = {"Head", "UpperTorso", "LowerTorso", "LeftLeg", "RightLeg", "LeftArm", "RightArm", "HumanoidRootPart"}
local selectedAimBone = "HumanoidRootPart"
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local espEnabled = false
local fillTriangles = false
local arrowTransparency = 1
local arrowColor = Color3.new(1, 0, 1)
local arrowSize = 10
local arrowThickness = 2
local arrowDistance = 200
local arrows = {}
local fullbrightToggle = false
local brightness = 0
local saturation = 0
local contrast = 0
local worldColor = Color3.fromRGB(255, 255, 255)
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local colorCorrection = Instance.new("ColorCorrectionEffect")
colorCorrection.Parent = Lighting


local highlightSettings = {
    FillColor = Color3.fromRGB(175, 25, 255),
    DepthMode = "AlwaysOnTop",
    FillTransparency = 0.5,
    OutlineColor = Color3.fromRGB(255, 255, 255),
    OutlineTransparency = 0
}

local Storage = Instance.new("Folder")
Storage.Parent = CoreGui
Storage.Name = "Apoc2_highlight_storage"

local function applyPlayerHighlight(plr)
    if plr == localPlayer then return end
    
    local Highlight = Instance.new("Highlight")
    Highlight.Name = plr.Name
    Highlight.FillColor = highlightSettings.FillColor
    Highlight.DepthMode = highlightSettings.DepthMode
    Highlight.FillTransparency = highlightSettings.FillTransparency
    Highlight.OutlineColor = highlightSettings.OutlineColor
    Highlight.OutlineTransparency = highlightSettings.OutlineTransparency
    Highlight.Parent = Storage
    
    local plrchar = plr.Character
    if plrchar then
        Highlight.Adornee = plrchar
    end

    connections[plr] = plr.CharacterAdded:Connect(function(char)
        Highlight.Adornee = char
    end)
end

local function removePlayerHighlight(plr)
    if Storage:FindFirstChild(plr.Name) then
        Storage[plr.Name]:Destroy()
    end
    if connections[plr] then
        connections[plr]:Disconnect()
    end
end

local function updateHighlights()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= localPlayer then
            if highlightEnabled then
                applyPlayerHighlight(plr)
            else
                removePlayerHighlight(plr)
            end
        end
    end
end

Players.PlayerAdded:Connect(function(plr)
    if highlightEnabled then
        applyPlayerHighlight(plr)
    end
end)

Players.PlayerRemoving:Connect(removePlayerHighlight)

local function applyFullbright()
    Lighting.Brightness = 2
    Lighting.ClockTime = 14
    Lighting.FogEnd = 100000
    Lighting.GlobalShadows = false
    Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
end

local function resetLighting()
    Lighting.Brightness = 1
    Lighting.ClockTime = 12
    Lighting.FogEnd = 100000
    Lighting.GlobalShadows = true
    Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
    for i,v in pairs(Lighting:GetDescendants()) do
        if v:IsA("Atmosphere") then
            v:Destroy()
        end
    end
end

local function updateVisualSettings()
    while true do
        if fullbrightToggle then
            applyFullbright()
        else
            resetLighting()
        end

        colorCorrection.Brightness = brightness
        colorCorrection.Saturation = saturation
        colorCorrection.Contrast = contrast
        colorCorrection.TintColor = worldColor

        RunService.RenderStepped:Wait()
    end
end


local function createFovCircle()
    if fovCircle then fovCircle:Remove() end
    fovCircle = Drawing.new("Circle")
    fovCircle.Color = fovColor
    fovCircle.Thickness = 1
    fovCircle.NumSides = 100
    fovCircle.Filled = false
    fovCircle.Transparency = fovTransparency
    fovCircle.Radius = fovRadius
end

createFovCircle()

local function updateFovCircle()
    if fovCircle and visibleFov then
        local viewportSize = workspace.CurrentCamera.ViewportSize
        fovCircle.Position = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    end
end

local function isInFov(targetPosition)
    if not useFov then return true end
    local viewportSize = workspace.CurrentCamera.ViewportSize
    local screenCenter = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    local distance = (targetPosition - screenCenter).Magnitude
    return distance <= fovRadius
end

local function getNearestPlayer()
    local nearestPlayer = nil
    local shortestDistance = math.huge
    local playerCharacter = player.Character
    if not playerCharacter or not playerCharacter:FindFirstChild("HumanoidRootPart") then return end
    local playerPosition = playerCharacter.HumanoidRootPart.Position

    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local otherPlayerPosition = otherPlayer.Character.HumanoidRootPart.Position
            local screenPoint = workspace.CurrentCamera:WorldToScreenPoint(otherPlayerPosition)
            local screenPosition = Vector2.new(screenPoint.X, screenPoint.Y)

            if isInFov(screenPosition) then
                local distance = (otherPlayerPosition - playerPosition).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end

    return nearestPlayer, shortestDistance
end

local function getClosestToMouse()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local viewportSize = workspace.CurrentCamera.ViewportSize
    local screenCenter = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)

    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local screenPoint = workspace.CurrentCamera:WorldToScreenPoint(otherPlayer.Character.HumanoidRootPart.Position)
            local screenPosition = Vector2.new(screenPoint.X, screenPoint.Y)
            
            if isInFov(screenPosition) then
                local distance = (screenPosition - screenCenter).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    closestPlayer = otherPlayer
                end
            end
        end
    end

    return closestPlayer, shortestDistance
end

local function isVisible(targetPosition)
    local ignoreList = {camera, player.Character}
    local ray = Ray.new(camera.CFrame.Position, (targetPosition - camera.CFrame.Position).unit * 5000)
    local hit, position = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
    return hit and hit:IsDescendantOf(targetPlayer.Character)
end

local function updateCrosshair()
    while isKeyPressed do
        if isScriptActive then
            local targetPlayer, distance
            if aimMode == "Nearest" then
                targetPlayer, distance = getNearestPlayer()
            else
                targetPlayer, distance = getClosestToMouse()
            end

            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild(selectedAimBone) then
                local aimPartPosition = targetPlayer.Character[selectedAimBone].Position

                if wallCheckEnabled and not isVisible(aimPartPosition) then
                    aimPartPosition = nil
                end

                if aimPartPosition then
                    local adjustedPosition = useYOffset and (aimPartPosition + Vector3.new(0, yOffsetPerStud * distance, 0)) or aimPartPosition
                    local screenPoint = camera:WorldToViewportPoint(adjustedPosition)

                    -- Ensure the crosshair and tracer update correctly even when zoomed
                    local crosshair = player:FindFirstChild("PlayerGui"):FindFirstChild("Interface Main")
                    if crosshair then
                        local reticle = crosshair:FindFirstChild("Reticle")
                        if reticle then
                            -- Adjust the crosshair position to match the tracer position
                            reticle.Position = UDim2.new(-0.5, screenPoint.X, -0.5, screenPoint.Y)
                        end
                    end

                    -- Tracer
                    if tracerEnabled then
                        if not tracer then
                            tracer = Drawing.new("Line")
                        end
                        tracer.Color = tracerColor
                        tracer.Thickness = 1
                        local viewportSize = camera.ViewportSize
                        tracer.From = Vector2.new(viewportSize.X / 2, viewportSize.Y / 2) -- Center by default
                        if tracerStart == "Top" then
                            tracer.From = Vector2.new(viewportSize.X / 2, 0)
                        elseif tracerStart == "Bottom" then
                            tracer.From = Vector2.new(viewportSize.X / 2, viewportSize.Y)
                        end
                        tracer.To = Vector2.new(screenPoint.X, screenPoint.Y)
                        tracer.Visible = true
                    end
                end
            end
        end
        RunService.RenderStepped:Wait()
    end
end




local function toggleScript(state)
    isScriptActive = state
end

local function fillFovCircle()
    if fovCircle then
        fovCircle.Filled = true
    end
end

local function unfillFovCircle()
    if fovCircle then
        fovCircle.Filled = false
    end
end


local function applyProjectionOffset()
    if isSilentAimEnabled then
        for _, character in pairs(workspace:GetChildren()) do
            if character.Name == "StarterCharacter" and character:FindFirstChild("Equipped") then
                local equipped = character:FindFirstChild("Equipped")
                for _, tool in pairs(equipped:GetChildren()) do
                    local projectionOffset = tool:FindFirstChild("ProjectionOffset")
                    if projectionOffset then
                        local crosshair = game.Players.LocalPlayer:FindFirstChild("PlayerGui"):FindFirstChild("Interface Main"):FindFirstChild("Reticle"):FindFirstChild("Crosshair")
                        if crosshair then
                            crosshair.Position = UDim2.new(0.5, projectionOffset.Value.X, 0.5, projectionOffset.Value.Y)
                        end
                    end
                end
            end
        end
    end
end


silentAimSection:Toggle({
    Name = "Silent Aim",
    Default = false,
    Callback = function(value)
        toggleScript(value)
    end
})

silentAimSection:Keybind({
    Name = "Aim Key",
    Default = aimKey,
    KeybindName = "Aim Key",
    Mode = "Hold",
    Callback = function(Input, State)
        isKeyPressed = State
        if isKeyPressed then
            coroutine.wrap(updateCrosshair)()
        else
            local crosshair = player:FindFirstChild("PlayerGui"):FindFirstChild("Interface Main"):FindFirstChild("Reticle"):FindFirstChild("Crosshair")
            if crosshair then
                crosshair.Position = UDim2.new(0.5, 0, 0.5, 0)
            end
            if tracer then
                tracer.Visible = false
            end
        end
    end
})

silentAimSection:Dropdown({
    Name = "Aim Mode",
    Default = "Nearest",
    Options = {"Nearest", "Closest to mouse"},
    Callback = function(value)
        aimMode = value
    end
})

silentAimSection:Dropdown({
    Name = "Aim Bone",
    Default = "HumanoidRootPart",
    Options = aimBones,
    Callback = function(value)
        selectedAimBone = value
    end
})

silentAimSection:Slider({
    Name = "FOV Radius",
    Min = 10,
    Max = 800,
    Default = 100,
    Callback = function(value)
        fovRadius = value
        fovCircle.Radius = fovRadius
    end
})

silentAimSection:Slider({
    Name = "FOV Transparency",
    Min = 0,
    Max = 1,
    Default = 1,
    Decimals = 0.1,
    Callback = function(value)
        fovTransparency = value
        fovCircle.Transparency = fovTransparency
    end
})

silentAimSection:Colorpicker({
    Name = "FOV Color",
    Default = fovColor,
    Callback = function(value)
        fovColor = value
        fovCircle.Color = fovColor
    end
})

silentAimSection:Toggle({
    Name = "Visible FOV",
    Default = false,
    Callback = function(value)
        visibleFov = value
        fovCircle.Visible = visibleFov
    end
})

silentAimSection:Toggle({
    Name = "Use FOV",
    Default = false,
    Callback = function(value)
        useFov = value
    end
})

silentAimSection:Toggle({
    Name = "Fill FOV",
    Default = false,
    Callback = function(value)
        if value then
            fillFovCircle()
        else
            unfillFovCircle()
        end
    end
})

silentAimSection:Toggle({
    Name = "WallCheck",
    Default = false,
    Callback = function(value)
        wallCheckEnabled = value
    end
})


local ReplicatedStorage = game:GetService("ReplicatedStorage")

otherSection:Slider({
    Name = "Bullet Velocity",
    Min = -30,
    Max = 0,
    Default = -19,
    Callback = function(value)
        local projectileGravity = ReplicatedStorage.Globals:FindFirstChild("ProjectileGravity")
        if projectileGravity then
            projectileGravity.Value = value
        end
    end
})




local zombieEspSettings = {
    enabled = false,
    textColor = Color3.fromRGB(255, 255, 255),
    textSize = 10,
    textDistance = 1000,
    textTransparency = 0,
    showDistance = false
}

local vehicleEspSettings = {
    enabled = false,
    textColor = Color3.fromRGB(255, 255, 255),
    textSize = 10,
    textDistance = 1000,
    textTransparency = 0,
    showDistance = false
}

local corpseEspSettings = {
    enabled = false,
    textColor = Color3.fromRGB(255, 255, 255),
    textSize = 10,
    textDistance = 1000,
    textTransparency = 0,
    showDistance = false
}

local eventEspSettings = {
    enabled = false,
    textColor = Color3.fromRGB(255, 255, 255),
    textSize = 10,
    textDistance = 1000,
    textTransparency = 0,
    showDistance = false
}

local borderColor = Color3.fromRGB(27, 42, 53)
local borderSize = 1
local colors = {
    "Black", "White", "Red", "Green", "Blue", "Yellow", "Orange", "Pink", "Purple", "Brown",
    "Cyan", "Magenta", "Lime", "Olive", "Navy", "Teal", "Maroon", "Silver", "Gray", "Gold",
    "Beige", "Coral", "Crimson", "Indigo", "Khaki"
}

local colorMap = {
    Black = Color3.fromRGB(0, 0, 0),
    White = Color3.fromRGB(255, 255, 255),
    Red = Color3.fromRGB(255, 0, 0),
    Green = Color3.fromRGB(0, 255, 0),
    Blue = Color3.fromRGB(0, 0, 255),
    Yellow = Color3.fromRGB(255, 255, 0),
    Orange = Color3.fromRGB(255, 165, 0),
    Pink = Color3.fromRGB(255, 192, 203),
    Purple = Color3.fromRGB(128, 0, 128),
    Brown = Color3.fromRGB(139, 69, 19),
    Cyan = Color3.fromRGB(0, 255, 255),
    Magenta = Color3.fromRGB(255, 0, 255),
    Lime = Color3.fromRGB(50, 205, 50),
    Olive = Color3.fromRGB(128, 128, 0),
    Navy = Color3.fromRGB(0, 0, 128),
    Teal = Color3.fromRGB(0, 128, 128),
    Maroon = Color3.fromRGB(128, 0, 0),
    Silver = Color3.fromRGB(192, 192, 192),
    Gray = Color3.fromRGB(128, 128, 128),
    Gold = Color3.fromRGB(255, 215, 0),
    Beige = Color3.fromRGB(245, 245, 220),
    Coral = Color3.fromRGB(255, 127, 80),
    Crimson = Color3.fromRGB(220, 20, 60),
    Indigo = Color3.fromRGB(75, 0, 130),
    Khaki = Color3.fromRGB(240, 230, 140)
}



local function enforceCrosshairSize()
    local crosshair
    -- Safely get the crosshair GUI element
    pcall(function()
        crosshair = player.PlayerGui:WaitForChild("Interface Main"):WaitForChild("Reticle"):WaitForChild("Crosshair"):WaitForChild("Crosshair")
    end)

    if crosshair then
        -- Set the initial size
        crosshair.Size = UDim2.new(0.01, 0, 0.01, 0)

        -- Connect a function to the Changed event
        crosshair:GetPropertyChangedSignal("Size"):Connect(function()
            if crosshair.Size ~= UDim2.new(0.01, 0, 0.01, 0) then
                crosshair.Size = UDim2.new(0.01, 0, 0.01, 0)
            end
        end)
    end
end




local function removeBillboardGuis(parent)
    for _, child in pairs(parent:GetChildren()) do
        if child:IsA("BillboardGui") then
            child:Destroy()
        end
    end
end

local function createTextLabel(target, text, color, size, transparency, distanceText)
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Adornee = target
    billboardGui.Size = UDim2.new(0, 200, 0, 100)
    billboardGui.StudsOffset = Vector3.new(0, 2, 0)
    billboardGui.AlwaysOnTop = true

    local textLabel = Instance.new("TextLabel")
    textLabel.Text = text
    textLabel.Size = UDim2.new(1, 0, 0.5, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.TextColor3 = color
    textLabel.TextSize = size
    textLabel.TextTransparency = transparency
    textLabel.Font = Enum.Font.Code
    textLabel.BorderSizePixel = 1
    textLabel.BorderColor3 = Color3.fromRGB(27, 42, 53)
    textLabel.Parent = billboardGui

    if distanceText then
        local distanceLabel = Instance.new("TextLabel")
        distanceLabel.Name = "DistanceLabel"
        distanceLabel.Text = distanceText
        distanceLabel.Size = UDim2.new(1, 0, 0.5, 0)
        distanceLabel.Position = UDim2.new(0, 0, 0.5, 0)
        distanceLabel.BackgroundTransparency = 1
        distanceLabel.TextColor3 = color
        distanceLabel.TextSize = size
        distanceLabel.TextTransparency = transparency
        distanceLabel.Font = Enum.Font.Code
        distanceLabel.BorderSizePixel = 1
        distanceLabel.BorderColor3 = Color3.fromRGB(27, 42, 53)
        distanceLabel.Parent = billboardGui
    end

    billboardGui.Parent = target
end

local function applyTextToZombies()
    local Mobs = workspace:WaitForChild("Zombies"):WaitForChild("Mobs")
    local localPlayer = game.Players.LocalPlayer

    for _, mob in pairs(Mobs:GetChildren()) do
        local head = mob:FindFirstChild("Head")
        if head and (localPlayer:DistanceFromCharacter(head.Position) <= zombieEspSettings.textDistance) then
            local distanceText = zombieEspSettings.showDistance and ("[" .. tostring(math.floor(localPlayer:DistanceFromCharacter(head.Position))) .. " Studs]") or nil
            removeBillboardGuis(head)
            createTextLabel(head, mob.Name, zombieEspSettings.textColor, zombieEspSettings.textSize, zombieEspSettings.textTransparency, distanceText)
        else
            removeBillboardGuis(head)
        end
    end
end

local function applyTextToVehicles()
    local Spawned = workspace:WaitForChild("Vehicles"):WaitForChild("Spawned")
    local localPlayer = game.Players.LocalPlayer

    for _, vehicle in pairs(Spawned:GetChildren()) do
        local base = vehicle:FindFirstChild("Base")
        if base and (localPlayer:DistanceFromCharacter(base.Position) <= vehicleEspSettings.textDistance) then
            local distanceText = vehicleEspSettings.showDistance and ("[" .. tostring(math.floor(localPlayer:DistanceFromCharacter(base.Position))) .. " Studs]") or nil
            removeBillboardGuis(base)
            createTextLabel(base, vehicle.Name, vehicleEspSettings.textColor, vehicleEspSettings.textSize, vehicleEspSettings.textTransparency, distanceText)
        else
            removeBillboardGuis(base)
        end
    end
end

local function applyTextToCorpses()
    local Corpses = workspace:WaitForChild("Corpses")
    local localPlayer = game.Players.LocalPlayer

    for _, corpse in pairs(Corpses:GetChildren()) do
        local head = corpse:FindFirstChild("Head")
        if head and (localPlayer:DistanceFromCharacter(head.Position) <= corpseEspSettings.textDistance) then
            local distanceText = corpseEspSettings.showDistance and ("[" .. tostring(math.floor(localPlayer:DistanceFromCharacter(head.Position))) .. " Studs]") or nil
            removeBillboardGuis(head)
            createTextLabel(head, corpse.Name, corpseEspSettings.textColor, corpseEspSettings.textSize, corpseEspSettings.textTransparency, distanceText)
        else
            removeBillboardGuis(head)
        end
    end
end

local function applyTextToEvents()
    local Events = workspace:WaitForChild("Map"):WaitForChild("Shared"):WaitForChild("Randoms")
    local localPlayer = game.Players.LocalPlayer

    for _, event in pairs(Events:GetChildren()) do
        local base = event:FindFirstChild("Base")
        if base and (localPlayer:DistanceFromCharacter(base.Position) <= eventEspSettings.textDistance) then
            local distanceText = eventEspSettings.showDistance and ("[" .. tostring(math.floor(localPlayer:DistanceFromCharacter(base.Position))) .. " Studs]") or nil
            removeBillboardGuis(base)
            createTextLabel(base, event.Name, eventEspSettings.textColor, eventEspSettings.textSize, eventEspSettings.textTransparency, distanceText)
        else
            removeBillboardGuis(base)
        end
    end
end

playerSection:Toggle({
    Name = "Enabled",
    Default = false,
    Callback = function(value)
        highlightEnabled = value
        updateHighlights()
    end
})

playerSection:Toggle({
    Name = "WallCheck",
    Default = false,
    Callback = function(value)
        wallCheckEnabled = value
        highlightSettings.DepthMode = value and "Occluded" or "AlwaysOnTop"
        for _, highlight in ipairs(Storage:GetChildren()) do
            highlight.DepthMode = highlightSettings.DepthMode
        end
    end
})

playerSection:Colorpicker({
    Name = "Fill Color",
    Default = highlightSettings.FillColor,
    Callback = function(value)
        highlightSettings.FillColor = value
        for _, highlight in ipairs(Storage:GetChildren()) do
            highlight.FillColor = value
        end
    end
})

playerSection:Slider({
    Name = "Fill Transparency",
    Min = 0,
    Max = 1,
    Default = highlightSettings.FillTransparency,
    Decimals = 0.1,
    Callback = function(value)
        highlightSettings.FillTransparency = value
        for _, highlight in ipairs(Storage:GetChildren()) do
            highlight.FillTransparency = value
        end
    end
})

playerSection:Colorpicker({
    Name = "Outline Color",
    Default = highlightSettings.OutlineColor,
    Callback = function(value)
        highlightSettings.OutlineColor = value
        for _, highlight in ipairs(Storage:GetChildren()) do
            highlight.OutlineColor = value
        end
    end
})

playerSection:Slider({
    Name = "Outline Transparency",
    Min = 0,
    Max = 1,
    Default = highlightSettings.OutlineTransparency,
    Decimals = 0.1,
    Callback = function(value)
        highlightSettings.OutlineTransparency = value
        for _, highlight in ipairs(Storage:GetChildren()) do
            highlight.OutlineTransparency = value
        end
    end
})


local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local runService = game:GetService("RunService")
local auraPart

local function createAuraPart()
    if not auraPart then
        auraPart = Instance.new("Part")
        auraPart.Anchored = true
        auraPart.CanCollide = false
        auraPart.Shape = Enum.PartType.Ball
        auraPart.Size = Vector3.new(auraDistance * 2, auraDistance * 2, auraDistance * 2)
        auraPart.Transparency = auraTransparency
        auraPart.Material = Enum.Material.Neon
        auraPart.Color = auraColor
        auraPart.Parent = workspace
    end
end

local function getNearestPlayer()
    local nearestPlayer = nil
    local shortestDistance = auraDistance

    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (character.HumanoidRootPart.Position - otherPlayer.Character.HumanoidRootPart.Position).Magnitude
            if distance < shortestDistance then
                nearestPlayer = otherPlayer
                shortestDistance = distance
            end
        end
    end

    return nearestPlayer
end

runService.RenderStepped:Connect(function()
    if meleeAuraEnabled then
        local nearestPlayer = getNearestPlayer()
        if nearestPlayer and nearestPlayer.Character and nearestPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local direction = (nearestPlayer.Character.HumanoidRootPart.Position - character.HumanoidRootPart.Position).unit
            local newCFrame = CFrame.new(character.HumanoidRootPart.Position, character.HumanoidRootPart.Position + direction)
            character.HumanoidRootPart.CFrame = newCFrame

            if showAuraPart then
                createAuraPart()
                auraPart.Position = nearestPlayer.Character.HumanoidRootPart.Position - Vector3.new(0, nearestPlayer.Character.HumanoidRootPart.Size.Y / 2, 0)
                auraPart.Size = Vector3.new(auraDistance * 2, auraDistance * 2, auraDistance * 2)
                auraPart.Transparency = auraTransparency
                auraPart.Color = auraColor
                auraPart.Parent = workspace
            else
                if auraPart then
                    auraPart.Parent = nil
                end
            end
        else
            if auraPart then
                auraPart.Parent = nil
            end
        end
    else
        if auraPart then
            auraPart.Parent = nil
        end
    end
end)


local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local replicatedStorage = game:GetService("ReplicatedStorage")
local itemsFolder = replicatedStorage:WaitForChild("Assets"):WaitForChild("Items", 10)
local userInputService = game:GetService("UserInputService")
local runService = game:GetService("RunService")

local materials = {
    "Plastic",
    "Wood",
    "Slate",
    "Concrete",
    "CorrodedMetal",
    "DiamondPlate",
    "Foil",
    "Grass",
    "Ice",
    "Marble",
    "Granite",
    "Brick",
    "Pebble",
    "Sand",
    "Fabric",
    "SmoothPlastic",
    "Metal",
    "WoodPlanks",
    "Cobblestone",
    "Air",
    "Water",
    "Rock",
    "Glacier",
    "Snow",
    "Sandstone",
    "Mud",
    "Basalt",
    "Ground",
    "CrackedLava",
    "Neon",
    "Glass",
    "ForceField"
}

local defaultSettings = {
    material = "Plastic",
    color = Color3.fromRGB(255, 255, 255),
    reflectance = 0,
    transparency = 0,
    adsFOV = 0.1
}

local settings = {
    enabled = false,
    material = defaultSettings.material,
    color = defaultSettings.color,
    reflectance = defaultSettings.reflectance,
    transparency = defaultSettings.transparency,
    adsFOV = defaultSettings.adsFOV,
    gunChamsEnabled = false,
    gunMaterial = defaultSettings.material,
    gunColor = defaultSettings.color,
    gunReflectance = defaultSettings.reflectance,
    gunTransparency = defaultSettings.transparency,
    backtrackEnabled = false,
    backtrackAmount = 0.1,
    infiniteJumpEnabled = false,
    jumpKey = Enum.KeyCode.Space,  -- Standardmäßig auf Space gesetzt
    cframeFlyEnabled = false,
    cframeFlySpeed = 1,
    cframeFlyKey = Enum.KeyCode.Space,
    cframeSpeedEnabled = false,
    cframeSpeed = 16,
}

local excludeParts = {
    "Base",
    "Constant",
    "LeftHandGrip",
    "Muzzle",
    "MuzzleFlash",
    "RightHandGrip",
    "SightLine",
    "BarrelMount",
    "SightMount",
    "UnderbarrelMount",
    "YesSight",
    "YesUnderbarrel"
}

local playerSettingsSection = PlayerPage:Section({
    Name = "LocalPlayer Chams",
    Fill = false,
    Side = "Left"
})

local adsFOVSection = PlayerPage:Section({
    Name = "ADS FOV",
    Fill = false,
    Side = "Right"
})

local gunChamsSection = PlayerPage:Section({
    Name = "Gun Chams",
    Fill = true,
    Side = "Left"
})

local backtrackSection = PlayerPage:Section({
    Name = "Backtrack", 
    Fill = false,
    Side = "Right"
})

local infiniteJumpSection = PlayerPage:Section({
    Name = "Localplayer Modifications",
    Fill = true,
    Side = "Right"
})

local function applySettings()
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" and part.Name ~= "HeadCollider" then
            part.Material = Enum.Material[settings.material]
            part.Color = settings.color
            part.Reflectance = settings.reflectance
            part.Transparency = settings.transparency
        end
    end
end

local function resetSettings()
    settings.material = defaultSettings.material
    settings.color = defaultSettings.color
    settings.reflectance = defaultSettings.reflectance
    settings.transparency = defaultSettings.transparency

    applySettings()
end

local function applyADSFOV()
    if itemsFolder then
        for _, model in pairs(itemsFolder:GetChildren()) do
            local sightLine = model:FindFirstChild("SightLine", true)
            if sightLine and sightLine:IsA("BasePart") then
                local size = sightLine.Size
                sightLine.Size = Vector3.new(size.X, size.Y, settings.adsFOV)
            end
        end
    end
end

local function applyGunChams()
    if itemsFolder then
        for _, model in pairs(itemsFolder:GetChildren()) do
            local part1 = model:FindFirstChild("1", true)
            local part2 = model:FindFirstChild("2", true)
            if part1 and part2 then
                for _, part in pairs(model:GetDescendants()) do
                    if part:IsA("BasePart") and not table.find(excludeParts, part.Name) then
                        part.Material = Enum.Material[settings.gunMaterial]
                        part.Color = settings.gunColor
                        part.Reflectance = settings.gunReflectance
                        part.Transparency = settings.gunTransparency
                    end
                end
            end
        end
    end
end

local function resetGunChams()
    settings.gunMaterial = defaultSettings.material
    settings.gunColor = defaultSettings.color
    settings.gunReflectance = defaultSettings.reflectance
    settings.gunTransparency = defaultSettings.transparency

    applyGunChams()
end

local function enableInfiniteJump()
    userInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and settings.infiniteJumpEnabled then
            if input.KeyCode == settings.jumpKey then
                local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                end
            end
        end
    end)
end

local function toggleCFrameFly()
    if settings.cframeFlyEnabled then
        runService.RenderStepped:Connect(function()
            if settings.cframeFlyEnabled then
                local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
                if humanoidRootPart then
                    humanoidRootPart.CFrame = humanoidRootPart.CFrame + (humanoidRootPart.CFrame.LookVector * settings.cframeFlySpeed)
                end
            end
        end)
    end
end

local moveDirection = Vector3.new(0, 0, 0)
local function updateMoveDirection()
    moveDirection = Vector3.new(0, 0, 0)
    if userInputService:IsKeyDown(Enum.KeyCode.W) then
        moveDirection = moveDirection + Vector3.new(0, 0, -1)
    end
    if userInputService:IsKeyDown(Enum.KeyCode.S) then
        moveDirection = moveDirection + Vector3.new(0, 0, 1)
    end
    if userInputService:IsKeyDown(Enum.KeyCode.A) then
        moveDirection = moveDirection + Vector3.new(-1, 0, 0)
    end
    if userInputService:IsKeyDown(Enum.KeyCode.D) then
        moveDirection = moveDirection + Vector3.new(1, 0, 0)
    end
end

local function toggleCFrameSpeed()
    local UserInputService = game:GetService('UserInputService')
    local RunService = game:GetService('RunService')
    local isCFrameSpeedActive = false
    
    local function cframeSpeed()
        repeat
            wait()
        until game:IsLoaded()
        
        local Players = game:GetService('Players')
        local LocalPlayer = Players.LocalPlayer
        
        repeat
            wait()
        until LocalPlayer.Character
        
        getgenv().Multiplier = settings.cframeSpeed -- Set initial speed from settings

        UserInputService.InputBegan:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.LeftBracket then
                getgenv().Multiplier = getgenv().Multiplier + 0.01
                print(getgenv().Multiplier)
                wait(0.2)
                while UserInputService:IsKeyDown(Enum.KeyCode.LeftBracket) do
                    wait()
                    getgenv().Multiplier = getgenv().Multiplier + 0.01
                    print(getgenv().Multiplier)
                end
            elseif input.KeyCode == Enum.KeyCode.RightBracket then
                getgenv().Multiplier = getgenv().Multiplier - 0.01
                print(getgenv().Multiplier)
                wait(0.2)
                while UserInputService:IsKeyDown(Enum.KeyCode.RightBracket) do
                    wait()
                    getgenv().Multiplier = getgenv().Multiplier - 0.01
                    print(getgenv().Multiplier)
                end
            elseif input.KeyCode == settings.cframeSpeedKey then -- Use the key from settings
                isCFrameSpeedActive = not isCFrameSpeedActive
                if isCFrameSpeedActive then
                    repeat
                        if settings.cframeSpeedEnabled then
                            LocalPlayer.Character.HumanoidRootPart.CFrame = LocalPlayer.Character.HumanoidRootPart.CFrame + LocalPlayer.Character.Humanoid.MoveDirection * getgenv().Multiplier
                        end
                        RunService.Stepped:Wait()
                    until not isCFrameSpeedActive
                end
            end
        end)
    end

    cframeSpeed()
end


enableInfiniteJump()
toggleCFrameFly()
toggleCFrameSpeed()

local arrows = {}

local function createESPArrow(target)
    local arrow = Drawing.new("Triangle")
    arrow.Color = arrowColor
    arrow.Thickness = arrowThickness
    arrow.Transparency = arrowTransparency
    arrow.Filled = fillTriangles
    arrow.Visible = false

    local function update()
        if not espEnabled then
            arrow.Visible = false
            return
        end

        if not target.Parent then
            arrow.Visible = false
            return
        end

        local screenPos, onScreen = Camera:WorldToViewportPoint(target.Position)
        if onScreen then
            arrow.Visible = false
        else
            local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            local direction = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Unit
            local arrowPosition = screenCenter + direction * arrowDistance -- Entfernung vom Bildschirmrand

            local perpDirection = Vector2.new(-direction.Y, direction.X) -- Senkrechter Vektor zur Richtung

            arrow.PointA = arrowPosition
            arrow.PointB = arrowPosition + perpDirection * arrowSize - direction * arrowSize * 2
            arrow.PointC = arrowPosition - perpDirection * arrowSize - direction * arrowSize * 2
            arrow.Visible = true
            arrow.Transparency = arrowTransparency
            arrow.Filled = fillTriangles
            arrow.Color = arrowColor
            arrow.Thickness = arrowThickness
        end
    end

    RunService.RenderStepped:Connect(update)
    return arrow
end

local function safeDivide(a, b)
    if a == nil or b == nil then
        warn("Attempt to divide by nil:", a, b)
        return 0 -- or some default value or behavior
    end
    return a / b
end


local function setupESPForPlayer(player)
    player.CharacterAdded:Connect(function(character)
        local rootPart = character:WaitForChild("HumanoidRootPart")
        local arrow = createESPArrow(rootPart)
        table.insert(arrows, {player = player, arrow = arrow})
    end)

    if player.Character then
        local rootPart = player.Character:WaitForChild("HumanoidRootPart")
        local arrow = createESPArrow(rootPart)
        table.insert(arrows, {player = player, arrow = arrow})
    end
end

for _, player in pairs(Players:GetPlayers()) do
    if player ~= Players.LocalPlayer then
        setupESPForPlayer(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= Players.LocalPlayer then
        setupESPForPlayer(player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    for i, v in ipairs(arrows) do
        if v.player == player then
            v.arrow:Remove()
            table.remove(arrows, i)
        end
    end
end)

Players.PlayerAdded:Connect(function(player)
    player.CharacterRemoving:Connect(function(character)
        for i, v in ipairs(arrows) do
            if v.player == player then
                v.arrow:Remove()
                table.remove(arrows, i)
            end
        end
    end)
end)


local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local function setZombieAnchoredState(state)
    for _, obj in next, workspace.Zombies.Mobs:GetChildren() do
        if obj:FindFirstChild("HumanoidRootPart") then
            obj.HumanoidRootPart.Anchored = state
        end
    end
end

local zombieFreezeToggle = antizombie:Toggle({
    Name = "Anti Zombie",
    Default = false,
    Callback = function(value)
        _G.anti_zombie = value
        setZombieAnchoredState(value)
    end
})

local zombieFreezeKeybind = antizombie:Keybind({
    Name = "Anti Zombie bind",
    Default = Enum.KeyCode.Space,
    Callback = function(key)
        UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if input.KeyCode == key and not gameProcessed then
                _G.anti_zombie = not _G.anti_zombie
                setZombieAnchoredState(_G.anti_zombie)
            end
        end)
    end
})

_G.anti_zombie = false
local function toggleNoclip(state)
    noclipEnabled = state
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()

    if noclipEnabled then
        connections["descendantAdded"] = character.DescendantAdded:Connect(function(part)
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end)

        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    else
        if connections["descendantAdded"] then
            connections["descendantAdded"]:Disconnect()
            connections["descendantAdded"] = nil
        end

        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

local function setupNoclipKeybind(key)
    local userInputService = game:GetService("UserInputService")

    userInputService.InputBegan:Connect(function(input, gameProcessed)
        if input.KeyCode == key and not gameProcessed then
            toggleNoclip(not noclipEnabled)
        end
    end)
end


OOVArrows:Toggle({
    Name = "Enable OOV Arrows",
    Default = false,
    Callback = function(value)
        espEnabled = value
    end
})


OOVArrows:Slider({
    Name = "Arrow Transparency",
    Min = 0,
    Max = 1,
    Default = 1,
    Decimals = 0.1,
    Callback = function(value)
        arrowTransparency = value
        for _, arrow in ipairs(arrows) do
            arrow.Transparency = value
        end
    end
})

OOVArrows:Colorpicker({
    Name = "Arrow Color",
    Default = arrowColor,
    Callback = function(value)
        arrowColor = value
        for _, arrow in ipairs(arrows) do
            arrow.Color = value
        end
    end
})

OOVArrows:Slider({
    Name = "Arrow Size",
    Min = 5,
    Max = 20,
    Default = 10,
    Callback = function(value)
        arrowSize = value
    end
})

OOVArrows:Slider({
    Name = "Arrow Thickness",
    Min = 1,
    Max = 5,
    Default = 2,
    Callback = function(value)
        arrowThickness = value
        for _, arrow in ipairs(arrows) do
            arrow.Thickness = value
        end
    end
})

OOVArrows:Slider({
    Name = "Arrow Distance",
    Min = 100,
    Max = 500,
    Default = 200,
    Callback = function(value)
        arrowDistance = value
    end
})

esponeSection:Toggle({
    Name = "Zombie Text",
    Default = false,
    Callback = function(value)
        zombieEspSettings.enabled = value
        if value then
            applyTextToZombies()
        else
            local Mobs = workspace:WaitForChild("Zombies"):WaitForChild("Mobs")
            for _, mob in pairs(Mobs:GetChildren()) do
                local head = mob:FindFirstChild("Head")
                if head then
                    removeBillboardGuis(head)
                end
            end
        end
    end
})

esponeSection:Colorpicker({
    Name = "Text Color",
    Default = zombieEspSettings.textColor,
    Callback = function(value)
        zombieEspSettings.textColor = value
        if zombieEspSettings.enabled then
            applyTextToZombies()
        end
    end
})

esponeSection:Slider({
    Name = "Text Size",
    Min = 1,
    Max = 100,
    Default = zombieEspSettings.textSize,
    Callback = function(value)
        zombieEspSettings.textSize = value
        if zombieEspSettings.enabled then
            applyTextToZombies()
        end
    end
})

esponeSection:Slider({
    Name = "Text Distance",
    Min = 1,
    Max = 100000,
    Default = zombieEspSettings.textDistance,
    Callback = function(value)
        zombieEspSettings.textDistance = value
        if zombieEspSettings.enabled then
            applyTextToZombies()
        end
    end
})

esponeSection:Slider({
    Name = "Text Transparency",
    Min = 0,
    Max = 1,
    Default = zombieEspSettings.textTransparency,
    Decimals = 0.1,
    Callback = function(value)
        zombieEspSettings.textTransparency = value
        if zombieEspSettings.enabled then
            applyTextToZombies()
        end
    end
})

esponeSection:Toggle({
    Name = "Show Distance",
    Default = false,
    Callback = function(value)
        zombieEspSettings.showDistance = value
        if zombieEspSettings.enabled then
            applyTextToZombies()
        end
    end
})

vehicleespSection:Toggle({
    Name = "Vehicle Text",
    Default = false,
    Callback = function(value)
        vehicleEspSettings.enabled = value
        if value then
            applyTextToVehicles()
        else
            local Spawned = workspace:WaitForChild("Vehicles"):WaitForChild("Spawned")
            for _, vehicle in pairs(Spawned:GetChildren()) do
                local base = vehicle:FindFirstChild("Base")
                if base then
                    removeBillboardGuis(base)
                end
            end
        end
    end
})

vehicleespSection:Colorpicker({
    Name = "Text Color",
    Default = vehicleEspSettings.textColor,
    Callback = function(value)
        vehicleEspSettings.textColor = value
        if vehicleEspSettings.enabled then
            applyTextToVehicles()
        end
    end
})

vehicleespSection:Slider({
    Name = "Text Size",
    Min = 1,
    Max = 100,
    Default = vehicleEspSettings.textSize,
    Callback = function(value)
        vehicleEspSettings.textSize = value
        if vehicleEspSettings.enabled then
            applyTextToVehicles()
        end
    end
})

vehicleespSection:Slider({
    Name = "Text Distance",
    Min = 1,
    Max = 100000,
    Default = vehicleEspSettings.textDistance,
    Callback = function(value)
        vehicleEspSettings.textDistance = value
        if vehicleEspSettings.enabled then
            applyTextToVehicles()
        end
    end
})

vehicleespSection:Slider({
    Name = "Text Transparency",
    Min = 0,
    Max = 1,
    Default = vehicleEspSettings.textTransparency,
    Decimals = 0.1,
    Callback = function(value)
        vehicleEspSettings.textTransparency = value
        if vehicleEspSettings.enabled then
            applyTextToVehicles()
        end
    end
})

vehicleespSection:Toggle({
    Name = "Show Distance",
    Default = false,
    Callback = function(value)
        vehicleEspSettings.showDistance = value
        if vehicleEspSettings.enabled then
            applyTextToVehicles()
        end
    end
})

esptwoSection:Toggle({
    Name = "Corpse Text",
    Default = false,
    Callback = function(value)
        corpseEspSettings.enabled = value
        if value then
            applyTextToCorpses()
        else
            local Corpses = workspace:WaitForChild("Corpses")
            for _, corpse in pairs(Corpses:GetChildren()) do
                local head = corpse:FindFirstChild("Head")
                if head then
                    removeBillboardGuis(head)
                end
            end
        end
    end
})

esptwoSection:Colorpicker({
    Name = "Text Color",
    Default = corpseEspSettings.textColor,
    Callback = function(value)
        corpseEspSettings.textColor = value
        if corpseEspSettings.enabled then
            applyTextToCorpses()
        end
    end
})

esptwoSection:Slider({
    Name = "Text Size",
    Min = 1,
    Max = 100,
    Default = corpseEspSettings.textSize,
    Callback = function(value)
        corpseEspSettings.textSize = value
        if corpseEspSettings.enabled then
            applyTextToCorpses()
        end
    end
})

esptwoSection:Slider({
    Name = "Text Distance",
    Min = 1,
    Max = 100000,
    Default = corpseEspSettings.textDistance,
    Callback = function(value)
        corpseEspSettings.textDistance = value
        if corpseEspSettings.enabled then
            applyTextToCorpses()
        end
    end
})

esptwoSection:Slider({
    Name = "Text Transparency",
    Min = 0,
    Max = 1,
    Default = corpseEspSettings.textTransparency,
    Decimals = 0.1,
    Callback = function(value)
        corpseEspSettings.textTransparency = value
        if corpseEspSettings.enabled then
            applyTextToCorpses()
        end
    end
})

esptwoSection:Toggle({
    Name = "Show Distance",
    Default = false,
    Callback = function(value)
        corpseEspSettings.showDistance = value
        if corpseEspSettings.enabled then
            applyTextToCorpses()
        end
    end
})

eventespSection:Toggle({
    Name = "Event Text",
    Default = false,
    Callback = function(value)
        eventEspSettings.enabled = value
        if value then
            applyTextToEvents()
        else
            local Events = workspace:WaitForChild("Map"):WaitForChild("Shared"):WaitForChild("Randoms")
            for _, event in pairs(Events:GetChildren()) do
                local base = event:FindFirstChild("Base")
                if base then
                    removeBillboardGuis(base)
                end
            end
        end
    end
})

eventespSection:Colorpicker({
    Name = "Text Color",
    Default = eventEspSettings.textColor,
    Callback = function(value)
        eventEspSettings.textColor = value
        if eventEspSettings.enabled then
            applyTextToEvents()
        end
    end
})

eventespSection:Slider({
    Name = "Text Size",
    Min = 1,
    Max = 100,
    Default = eventEspSettings.textSize,
    Callback = function(value)
        eventEspSettings.textSize = value
        if eventEspSettings.enabled then
            applyTextToEvents()
        end
    end
})

eventespSection:Slider({
    Name = "Text Distance",
    Min = 1,
    Max = 100000,
    Default = eventEspSettings.textDistance,
    Callback = function(value)
        eventEspSettings.textDistance = value
        if eventEspSettings.enabled then
            applyTextToEvents()
        end
    end
})

eventespSection:Slider({
    Name = "Text Transparency",
    Min = 0,
    Max = 1,
    Default = eventEspSettings.textTransparency,
    Decimals = 0.1,
    Callback = function(value)
        eventEspSettings.textTransparency = value
        if eventEspSettings.enabled then
            applyTextToEvents()
        end
    end
})

eventespSection:Toggle({
    Name = "Show Distance",
    Default = false,
    Callback = function(value)
        eventEspSettings.showDistance = value
        if eventEspSettings.enabled then
            applyTextToEvents()
        end
    end
})

silentAimSection:Toggle({
    Name = "Target Tracer",
    Default = false,
    Callback = function(value)
        tracerEnabled = value
    end
})

silentAimSection:Dropdown({
    Name = "Tracer Location",
    Default = "Center",
    Options = {"Center", "Top", "Bottom"},
    Callback = function(value)
        tracerStart = value
    end
})

silentAimSection:Colorpicker({
    Name = "Tracer Color",
    Default = tracerColor,
    Callback = function(value)
        tracerColor = value
    end
})


silentAimSection:Toggle({
    Name = "Use Y Offset per Stud [Dont touch !]",
    Default = false,
    Callback = function(value)
        useYOffsetPerStud = value
    end
})


silentAimSection:Slider({
    Name = "YOffset per Stud [Experimental]",
    Min = -0.0500,
    Max = 1,
    Default = 0,
    Decimals = 0.0001,
    Callback = function(value)
        yOffsetPerStud = value
    end
})

otherSection:Toggle({
    Name = "Enforce Crosshair Size",
    Default = false,
    Callback = function(value)
        enforceCrosshairSizeEnabled = value
        if enforceCrosshairSizeEnabled then
            enforceCrosshairSize()
        end
    end
})

worldSection:Toggle({
    Name = "Fullbright",
    Default = false,
    Callback = function(value)
        fullbrightToggle = value
    end
})

worldSection:Colorpicker({
    Name = "World Color",
    Default = worldColor,
    Callback = function(value)
        worldColor = value
    end
})

worldSection:Slider({
    Name = "Brightness",
    Min = -1,
    Max = 1,
    Default = 0,
    Decimals = 0.01,
    Callback = function(value)
        brightness = value
    end
})

worldSection:Slider({
    Name = "Saturation",
    Min = -1,
    Max = 1,
    Default = 0,
    Decimals = 0.01,
    Callback = function(value)
        saturation = value
    end
})

worldSection:Slider({
    Name = "Contrast",
    Min = -1,
    Max = 1,
    Default = 0,
    Decimals = 0.01,
    Callback = function(value)
        contrast = value
    end
})

worldSection:Button({
    Name = "Reset",
    Callback = function()
        brightness = 0
        saturation = 0
        contrast = 0
        worldColor = Color3.fromRGB(255, 255, 255)
    end
})


meleeAuraToggle:Toggle({
    Name = "MeleeAura",
    Default = false,
    Callback = function(value)
        meleeAuraEnabled = value
    end
})

meleeAuraToggle:Toggle({
    Name = "Show Aura Part",
    Default = false,
    Callback = function(value)
        showAuraPart = value
    end
})

meleeAuraToggle:Slider({
    Name = "Aura Distance",
    Min = 1,
    Max = 10,
    Default = 6,
    Decimals = 1,
    Callback = function(value)
        auraDistance = value
    end
})

meleeAuraToggle:Slider({
    Name = "Aura Transparency",
    Min = 0,
    Max = 1,
    Default = 0.5,
    Decimals = 0.1,
    Callback = function(value)
        auraTransparency = value
        if auraPart then
            auraPart.Transparency = value
        end
    end
})

meleeAuraToggle:Colorpicker({
    Name = "Aura Color",
    Default = Color3.new(1, 1, 1),
    Callback = function(color)
        auraColor = color
        if auraPart then
            auraPart.Color = color
        end
    end
})


-- Toggle for LocalPlayer Settings
playerSettingsSection:Toggle({
    Name = "Enable",
    Default = settings.enabled,
    Callback = function(value)
        settings.enabled = value
        if value then
            applySettings()
        else
            resetSettings()
        end
    end
})

-- Dropdown for Material
playerSettingsSection:Dropdown({
    Name = "Material",
    Default = settings.material,
    Options = materials,
    Callback = function(value)
        settings.material = value
        if settings.enabled then
            applySettings()
        end
    end
})

-- Color Picker for Color
playerSettingsSection:Colorpicker({
    Name = "Color",
    Default = settings.color,
    Callback = function(color)
        settings.color = color
        if settings.enabled then
            applySettings()
        end
    end
})

-- Slider for Reflectance
playerSettingsSection:Slider({
    Name = "Reflectance",
    Min = 0,
    Max = 1,
    Default = settings.reflectance,
    Decimals = 0.1,
    Callback = function(value)
        settings.reflectance = value
        if settings.enabled then
            applySettings()
        end
    end
})

-- Slider for Transparency
playerSettingsSection:Slider({
    Name = "Transparency",
    Min = 0,
    Max = 1,
    Default = settings.transparency,
    Decimals = 0.1,
    Callback = function(value)
        settings.transparency = value
        if settings.enabled then
            applySettings()
        end
    end
})

-- Reset Button
playerSettingsSection:Button({
    Name = "Reset",
    Callback = function()
        resetSettings()
    end
})

-- Slider for ADS FOV
adsFOVSection:Slider({
    Name = "ADS FOV",
    Min = 0.1,
    Max = 50,
    Default = settings.adsFOV,
    Decimals = 1,
    Callback = function(value)
        settings.adsFOV = value
        applyADSFOV()
    end
})

-- Toggle for Gun Chams Settings
gunChamsSection:Toggle({
    Name = "Enable",
    Default = settings.gunChamsEnabled,
    Callback = function(value)
        settings.gunChamsEnabled = value
        if value then
            applyGunChams()
        else
            resetGunChams()
        end
    end
})

-- Dropdown for Gun Material
gunChamsSection:Dropdown({
    Name = "Material",
    Default = settings.gunMaterial,
    Options = materials,
    Callback = function(value)
        settings.gunMaterial = value
        if settings.gunChamsEnabled then
            applyGunChams()
        end
    end
})

-- Color Picker for Gun Color
gunChamsSection:Colorpicker({
    Name = "Color",
    Default = settings.gunColor,
    Callback = function(color)
        settings.gunColor = color
        if settings.gunChamsEnabled then
            applyGunChams()
        end
    end
})

-- Slider for Gun Reflectance
gunChamsSection:Slider({
    Name = "Reflectance",
    Min = 0,
    Max = 1,
    Default = settings.gunReflectance,
    Decimals = 0.1,
    Callback = function(value)
        settings.gunReflectance = value
        if settings.gunChamsEnabled then
            applyGunChams()
        end
    end
})

-- Slider for Gun Transparency
gunChamsSection:Slider({
    Name = "Transparency",
    Min = 0,
    Max = 1,
    Default = settings.gunTransparency,
    Decimals = 0.1,
    Callback = function(value)
        settings.gunTransparency = value
        if settings.gunChamsEnabled then
            applyGunChams()
        end
    end
})

-- Reset Button for Gun Chams
gunChamsSection:Button({
    Name = "Reset",
    Callback = function()
        resetGunChams()
    end
})

-- Backtrack Section
backtrackSection:Toggle({
    Name = "Enable Backtrack",
    Default = settings.backtrackEnabled,
    Callback = function(value)
        settings.backtrackEnabled = value
        if value then
            game:GetService("NetworkSettings").IncomingReplicationLag = settings.backtrackAmount
        else
            game:GetService("NetworkSettings").IncomingReplicationLag = 0
        end
    end
})

backtrackSection:Slider({
    Name = "Backtrack Amount",
    Min = 0,
    Max = 1.5,
    Default = settings.backtrackAmount,
    Decimals = 2,
    Callback = function(value)
        settings.backtrackAmount = value
        if settings.backtrackEnabled then
            game:GetService("NetworkSettings").IncomingReplicationLag = value
        end
    end
})

-- Infinite Jump Section
infiniteJumpSection:Toggle({
    Name = "Enable Infinite Jump",
    Default = settings.infiniteJumpEnabled,
    Callback = function(value)
        settings.infiniteJumpEnabled = value
    end
})

-- Key Picker for Jump Key
infiniteJumpSection:Keybind({
    Name = "Jump Key",
    Default = settings.jumpKey,
    Callback = function(key)
        settings.jumpKey = key
    end
})

infiniteJumpSection:Toggle({
    Name = "Enable Noclip",
    Default = false,
    Callback = function(value)
        toggleNoclip(value)
    end
})

infiniteJumpSection:Keybind({
    Name = "Noclip Keybind",
    Default = Enum.KeyCode.N,
    Callback = function(key)
        setupNoclipKeybind(key)
    end
})


infiniteJumpSection:Toggle({
    Name = "Enable CFrame Speed",
    Default = settings.cframeSpeedEnabled,
    Callback = function(value)
        settings.cframeSpeedEnabled = value
    end
})

-- Slider für die CFrame-Geschwindigkeit
infiniteJumpSection:Slider({
    Name = "CFrame Speed",
    Min = 0,
    Max = 1,
    Default = settings.cframeSpeed,
    Decimals = 0.1,
    Callback = function(value)
        settings.cframeSpeed = value
        getgenv().Multiplier = value -- Update the global multiplier
    end
})

-- Keybind für die CFrame-Geschwindigkeit
infiniteJumpSection:Keybind({
    Name = "CFrame Speed Key",
    Default = settings.cframeSpeedKey,
    Callback = function(key)
        settings.cframeSpeedKey = key
    end
})

ESPSection:Toggle({
    Name = "Enable ESP",
    Default = true,
    Callback = function(value)
        features.visuals.enabled = value
    end
})

ESPSection:Toggle({
    Name = "Bounding Box",
    Default = true,
    Callback = function(value)
        features.visuals.boundingBox = value
    end
})

ESPSection:Toggle({
    Name = "Box Outline",
    Default = true,
    Callback = function(value)
        features.visuals.boxes.outline.enabled = value
    end
})

ESPSection:Toggle({
    Name = "Box Fill",
    Default = true,
    Callback = function(value)
        features.visuals.boxes.filled.enabled = value
    end
})

ESPSection:Toggle({
    Name = "Show Names",
    Default = true,
    Callback = function(value)
        features.visuals.names.enabled = value
    end
})


ESPSection:Toggle({
    Name = "Show Health",
    Default = true,
    Callback = function(value)
        features.visuals.health.enabled = value
    end
})


ESPSection:Toggle({
    Name = "Health Text",
    Default = true,
    Callback = function(value)
        features.visuals.health.text.enabled = value
    end
})

ESPSection:Toggle({
    Name = "Show Distance",
    Default = true,
    Callback = function(value)
        features.visuals.distance.enabled = value
    end
})


ESPSection:Toggle({
    Name = "Show Weapon",
    Default = true,
    Callback = function(value)
        features.visuals.weapon.enabled = value
    end
})



ESPSection:Toggle({
    Name = "View Direction",  -- View Direction Toggle
    Default = false,
    Callback = function(value)
        features.visuals.viewDirection.enabled = value
    end
})

ESPSection:Slider({
    Name = "View Direction Length",  -- Slider for View Direction Length
    Min = 1,
    Max = 10,
    Default = 5,
    Callback = function(value)
        features.visuals.viewDirection.length = value
    end
})

ESPSection:Slider({
    Name = "Render Distance",
    Min = 0,
    Max = 5000,
    Default = 2000,
    Callback = function(value)
        features.visuals.renderDistance = value
    end
})

ESPSection:Colorpicker({
    Name = "Box Color",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(value)
        features.visuals.boxes.color = value
    end
})



ESPSection:Colorpicker({
    Name = "Box Fill Color",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(value)
        features.visuals.boxes.filled.color = value
    end
})

ESPSection:Slider({
    Name = "Box Fill Transparency",
    Min = 0,
    Max = 1,
    Default = 0.25,
    Callback = function(value)
        features.visuals.boxes.filled.transparency = value
    end
})

ESPSection:Colorpicker({
    Name = "Health Color",
    Default = Color3.fromRGB(0, 255, 0),
    Callback = function(value)
        features.visuals.health.color = value
    end
})

ESPSection:Colorpicker({
    Name = "Low Health Color",
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(value)
        features.visuals.health.colorLow = value
    end
})



ESPSection:Colorpicker({
    Name = "Distance Color",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(value)
        features.visuals.distance.color = value
    end
})



ESPSection:Colorpicker({
    Name = "Weapon Color",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(value)
        features.visuals.weapon.color = value
    end
})



ESPSection:Colorpicker({
    Name = "View Direction Color",  -- Color Picker for View Direction
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(value)
        features.visuals.viewDirection.color = value
    end
})

coroutine.wrap(updateVisualSettings)()

Window:Initialize()

local RunService = game:GetService("RunService")

RunService.RenderStepped:Connect(function()
    updateFovCircle()
end)
